<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>WDD 330 Week 3</title>
    <meta name="description" content="WDD330 notes, exercises, challenges">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="css/styles.css" rel="stylesheet">
</head>

<body>
    <a href="../index.html">
        <header>
            <h1>Anna Astle WDD 330</h1>
        </header>
    </a>
    <main>
        <h2><a href="index.html">Week 3</a></h2>

        <h3>Ch5: Objects</h3>
        <ul>
            <li><span>Object Literals</span>
                <ul><li>set of related values and functions</li>
                <li>can inherit from other objects</li>
                <li>defined with "{}"</li>
                 <li>allow for quick creation objects without need of a class</li>
                 <li>key/value pairs separated by ","</li>
                 <li>key with a space needs ""</li>
                 <li>it is better just follow rules for naming variables when naming keys</li>
                 <li>mutable even while using <span>const</span></li>
                </ul>
            </li>
            <li>Object can also be created with "new Object()"- not recommended</li>
            <li><span>Shorthand method of creating objects</span> if a property key is the same as a variable name that the property value is
            assigned to</li>
            <li><span>undefind</span> returned if a property does not exist</li>
            <li><span>Computed Properties</span>
                <ul><li>Using "[]" is preferer over "." if you want to concat to create property</li></ul>
            </li>
            <li>A value of a property can be a <span>ternary operator</span> that returns true or false </li>
            <li>The <span>Symbol data type</span> can also be used as a computed property key
                <ul><li>The symbols used for property keys are not limited to being used by only one object - they can be reused by any other
                object</li>
            <li>using them as property keys avoids any naming clashes if you mistakenly use the same value for two different property
            keys</li></ul>
            </li>
            <li><span>Checking if Properties or Methods Exist</span>
                <ul>
                 <li>city <span>"in"</span> superman</li>
                 <li>see if does not returned "undefined"</li>
                 <li><span>hasOwnProperty()</span>
                    <ul><li>will check whether an object has a property that is its own, rather than one that has been inherited from another object (which are included in above methods)</li>
                    </ul>
                 </li>
                </ul>
                </li>
            <li><span>Finding all the Properties of an Object</span>
                <ul>
                    <li><span>"for in"</span> loop</li>
                    <li>To make sure that only an objectâ€™s own properties are returned, a quick check can be implemented beforehand:
                        <ul><li><span>for(const key in superman) {
                        if(superman.hasOwnProperty(key)){
                        console.log(key + ": " + superman[key]);
                        }
                        }</span></li></ul>
                        <li><span>Object.keys()</span> returns an array of all the keys of any object that is provided as an argument</li>
                        <li><span>Object.values()</span></li>
                        <li><span>Object.entries()</span> returns array of key/value pairs</li>
                    </li>
                </ul>
            </li>
            <li><span>delete</span> keyword used to remove property</li>
            <li><span>Nested Objects</span> objects within objects</li>
            <li>objects are assigned by <span>reference</span>
                <ul>
                    <li>if a variable is assigned to an object that already exists, it will simply point to the exact same space in memory</li>
                    <li>any changes made usingeitherreference will affect the same object</li>
                </ul>
            </li>
            <li><span>Objects as Parameters to Functions</span>
                <ul>
                    <li>useful when there are a large number of parameters</li>
                    <li>also order of arguments doesn't matter</li>
                    <li>parameters can have default values</li>
                    <li><span>named parameters</span></li>
                </ul>
            </li>
            <li><span>"this"</span></li>
            <li><span>Namespacing</span> 
                <ul>
                    <li>help solve <span>naming collisions problems</span></li>
                    <li><span>object literal pattern</span>
                        <ul>
                            <li>creates namespace for groups of related functions</li>
                            <li>This is done by creating an object literal that serves as the namespace, then adding any values as properties of that
                            object, and any functions as methods.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><span>Built-in-Objects</span>
                <ul><li>Arrays & Functions</li></ul>
            </li>
            <li><span>JSON</span>
                <ul>
                    <li>"popular lightweight data-storage format that is used by a large number of services for data serialization and
                    configuration"</li>
                    <li><span>Object Literal Notation in JSON</span>
                        <ul><li>Property names must be double-quoted
                        <li>Permitted values are double-quoted strings, numbers, true, false, null, arrays and objects</li> 
                        <li>Functions are not permitted values</li></ul>
                    </li>
                    <li><span>JSON.parse()</span> method takes a string of data in JSON format and returns a JavaScript object</li>
                    <li><span>JSON.stringify() </span> does opposite of parse()<ul><li>can also add a space argument that will add new lines between each key-value pair,</li></ul></li>
                    <li>These methods are particularly useful when it comes to sending data to, and receiving data from, a web server using Ajax
                    requests</li>
                </ul>
            </li>
            <hr>
            <li><span>Math Object</span>
                <ul>
                    <li>.PI</li>
                    <li>.SQRT2</li>
                    <li>.SQRT1_2</li>
                    <li>.E</li>
                    <li>.LN2</li>
                    <li>.LN10</li>
                    <li>.LOG2E</li>
                    <li>.LOG10E</li>
                    <hr>
                    <li>.abs()</li>
                    <li>.ceil()</li>
                    <li>.floor()</li>
                    <li>.round()</li>
                    <li>.trunc()</li>
                    <li>.exp()</li>
                    <li>.pow()</li>
                    <li>.sqrt()</li>
                    <li>.cbrt()</li>
                    <li>.hypot()</li>
                    <li>.log()
                        <ul>
                            <li>.log2()</li>
                            <li>.log10()</li>
                        </ul>
                    </li>
                    <li>.max()</li>
                    <li>.min()</li>
                    <li>functions also exit for all trig functions</li>
                    <li>.random()</li>
            
                </ul>
            </li>
            <hr>
            <li><span>The Date Object</span>
                <ul>
                    <li>const today = new Date()</li>
                    <li><span>toString()</span> view object in string form</li>
                    <li>new Date(year,month,day,hour,minutes,seconds,milliseconds)</li>
                    <li><span>Epoch</span> 1st January 1970</li>
                    <li><span>Get</span>
                        <ul>
                            <li>returns info in local time
                                <ul>
                                    <li>getTime()</li>
                                    <li>getTimezoneOffset()</li>
                                    <li>getYear()</li>
                                </ul>
                            </li>
                            <li>return info in UTC
                                <ul>
                                    <li><span>UTC</span> -pretty much GMC except it is a standard defined by scientific community
                                    </li>
                                    <li>getDay(), getUTCDay()</li>
                                    <li>getDate(), getUTCDate()</li>
                                    <li>getMonth(), getUTCMonth()</li>
                                    <li>getFullYear(), getUTCFullYear()</li>
                                    <li>getHours() , getUTCHours() , getMinutes() , getUTCMinutes() , getSeconds() , getUTCSeconds ,
                                        getMilliseconds() ,
                                        getUTCMilliseconds()</li>
                                    <li>getTime()</li>
                                    <li>getTimezoneOffset()</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><span>Setter Methods</span>
                        <ul>
                            <li>setDate(), setMonth(), setFullYear()</li>
                            <li>setHours() , setUTCHours() , setMinutes() , setUTCMinutes() , setSeconds() , setUTCSeconds ,
                                setMilliseconds(),
                                setUTCMilliseconds()</li>
                            <li>setTime()</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <hr>
            <li><span>RegExp Object</span>
                <ul>
                    <li>create
                        <ul>
                            <li><span>literal notation</span> const pattern = /[a-zA-Z]+ing$/; <i>*preferred method</i></li>
                            <li>const pattern = new RegExp('[a-zA-Z]+ing');
                                <ul>
                                    <li>lets you create regular expressions using strings, which can be useful when the regular expression is provided from user input</li>
                                    <li>constructors also have the advantage of letting you create a regular expression using a variable</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><span>Methods</span>
                        <ul>
                            <li>test()</li>
                            <li>exec()</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
</main>
<script src="js/main.js"></script>
</body>

</html>